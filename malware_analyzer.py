import subprocess
import time
import json
import re
import threading
from http.server import HTTPServer, BaseHTTPRequestHandler

MALICIOUS_KEYWORDS = ["exploit", "backdoor", "trojan", "malware"]
HTTP_SERVER_PORT = 8080

class MalwareAnalyzer:
    def __init__(self, malware_path):
        self.malware_path = malware_path
        self.analysis_results = {
            "malware_path": malware_path,
            "timestamp": time.ctime(),
            "behavior": [],
            "network_traffic": [],
            "static_analysis": {}
        }

    def run_malware(self):
        sandbox_command = f"python {self.malware_path}"  # Substitua isso pela forma como você executaria o malware

        try:
            process = subprocess.Popen(sandbox_command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            stdout, stderr = process.communicate(timeout=30)  # Defina o tempo limite adequado

            self.analysis_results["behavior"].append({
                "type": "stdout",
                "data": stdout.decode("utf-8")
            })

            self.analysis_results["behavior"].append({
                "type": "stderr",
                "data": stderr.decode("utf-8")
            })

            print("Análise concluída.")

            # Simulação de tráfego de rede para análise dinâmica
            self.simulate_network_traffic()

            # Salvar resultados em um arquivo JSON
            result_filename = "malware_analysis_result.json"
            with open(result_filename, "w") as result_file:
                json.dump(self.analysis_results, result_file, indent=4)

            print(f"Resultados salvos em '{result_filename}'.")
        except subprocess.TimeoutExpired:
            print("Tempo limite de análise excedido.")

    def simulate_network_traffic(self):
        # Simulação de tráfego de rede HTTP para análise dinâmica
        def run_server():
            server_address = ("", HTTP_SERVER_PORT)
            httpd = HTTPServer(server_address, HTTPRequestHandler)
            print(f"Servidor HTTP iniciado na porta {HTTP_SERVER_PORT}.")
            httpd.serve_forever()

        class HTTPRequestHandler(BaseHTTPRequestHandler):
            def do_GET(self):
                self.send_response(200)
                self.send_header("Content-type", "text/html")
                self.end_headers()
                self.wfile.write(b"Resposta simulada do servidor")

                self.log_network_traffic("GET", self.path)

        network_thread = threading.Thread(target=run_server)
        network_thread.daemon = True
        network_thread.start()

    def log_network_traffic(self, method, path):
        self.analysis_results["network_traffic"].append({
            "method": method,
            "path": path,
            "timestamp": time.ctime()
        })

    def detect_malicious_keywords(self):
        keywords_found = []
        for behavior in self.analysis_results["behavior"]:
            for keyword in MALICIOUS_KEYWORDS:
                if re.search(keyword, behavior["data"], re.I):
                    keywords_found.append(keyword)

        if keywords_found:
            print("Comportamento malicioso detectado:")
            for keyword in keywords_found:
                print(f"- Palavra-chave: {keyword}")
            self.analysis_results["malicious_behavior"] = keywords_found
        else:
            print("Nenhum comportamento malicioso detectado.")

    def static_code_analysis(self):
        with open(self.malware_path, "r") as malware_file:
            code = malware_file.read()

            suspicious_patterns = []
            for keyword in MALICIOUS_KEYWORDS:
                if re.search(keyword, code, re.I):
                    suspicious_patterns.append(keyword)

            self.analysis_results["static_analysis"]["suspicious_patterns"] = suspicious_patterns

            dangerous_functions = ["eval", "exec", "os.system", "__import__"]
            dangerous_calls = [call for call in dangerous_functions if call in code]
            
            self.analysis_results["static_analysis"]["dangerous_function_calls"] = dangerous_calls


    def generate_html_report(self):
        report = f"""
        <html>
        <head><title>Relatório de Análise de Malware</title></head>
        <body>
        <h1>Relatório de Análise de Malware</h1>
        <p><strong>Malware:</strong> {self.analysis_results["malware_path"]}</p>
        <p><strong>Timestamp:</strong> {self.analysis_results["timestamp"]}</p>

        <h2>Comportamento Analisado</h2>
        <ul>
        """
        for behavior in self.analysis_results["behavior"]:
            report += f"<li><strong>{behavior['type']}:</strong><br>{behavior['data']}</li>"
        report += """
        </ul>

        <h2>Tráfego de Rede Simulado</h2>
        <ul>
        """
        for traffic in self.analysis_results["network_traffic"]:
            report += f"<li><strong>{traffic['method']} {traffic['path']}:</strong> {traffic['timestamp']}</li>"
        report += """
        </ul>

        </body>
        </html>
        """

        with open("malware_analysis_report.html", "w") as report_file:
            report_file.write(report)

if __name__ == "__main__":
    malware_path = "path/to/your/malware.py"  # Substitua pelo caminho para o malware
    analyzer = MalwareAnalyzer(malware_path)

    analyzer.run_malware()
    analyzer.detect_malicious_keywords()
    analyzer.static_code_analysis()
    analyzer.generate_html_report()

    print("Análise concluída. Resultados salvos no relatório HTML 'malware_analysis_report.html'.")
